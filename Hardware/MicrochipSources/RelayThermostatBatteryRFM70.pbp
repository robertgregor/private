'@  __config _INTRC_OSC_NOCLKOUT & _WDT_ON & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _FCMEN_OFF & _IESO_OFF & _BOR_ON & _PWRTE_ON
                 
@ DEVICE PIC16F690,INTRC_OSC_NOCLKOUT
@ DEVICE PIC16F690,WDT_ON
@ DEVICE PIC16F690,MCLR_OFF
@ DEVICE PIC16F690,CPD_OFF
@ DEVICE PIC16F690,BOD_ON
@ DEVICE PIC16F690,PWRT_ON

'EEPROM_MAP
'0 - channel number
'1,2,3,4,5 bank name
'6 device id
'7 full range highByte
'8 full range lowbyte
'9 interval

INCLUDE "RFM70.pbp"

EEPROM  0, [40,"R","O","B","I","K",0,0,0,0,0,0,0,0,0,0]

 DEFINE OSC 8
 DEFINE ADC_BITS 10 ' ADCIN resolution (Bits)
 DEFINE ADC_CLOCK 3 ' ADC clock source (Fosc/32)
 DEFINE ADC_SAMPLEUS 50 ' ADC sampling time (uSec)
 ADCON0.7 = 1
 
 OSCCON = %01110000 ' Internal 8MHz osc
 ANSEL = %10000000
 ANSELH = 0
 CM1CON0 = 0
 CM2CON0 = 0
 
 'interrupt for timer
 INTCON = %10100000
 PIE1 = %00000000
 OPTION_REG = %00000111

on interrupt goto intManagement
ENABLE
'-----------init----------------------------------------------------------------
TRISA = %00100000 'Set PORTA to all output
TRISB = %00010000 'Set , SDI input
TRISC = %00001100 'Set IRQ input, 

HEATING_SENSOR var PORTA.5
HEATING_SENSOR_power var PORTA.4
MOTOR_1 var PORTC.4
MOTOR_2 var PORTC.5
MOTOR_ANALOG VAR PORTC.3
motorRunning VAR byte
motorAnVal var word
motorValNoPower var word
motorAnDownCount VAR byte
motorStrengthConstant var byte
motorStrengthConstant = 1    'this should be configurable
motorFullRangeTicks var word
motorFullRangeCurrentTicks var word
motorFullRangeExpectedTicks var word
testAnInterrupt var word
i VAR BYTE 'loop counter
j var byte
ic var byte
VDD VAR WORD
confSuccess var byte
configure var byte
manageSerial var byte
temp_byte_int var byte
temp_byte var byte
temp1_byte var byte
temp2_byte var byte
temp_word var word
temperature var word
seconds  var    byte    ' Define second variable
ticks   var     byte    ' Define pieces of seconds variable
dat var word 'unscaled ADC data
normalMode VAR byte
sendCurrPosFlag VAR byte
sendCurrPosFlag2 var byte
Dummy       VAR BYTE
TempC       VAR WORD
Float       VAR WORD        
busy        var BIT
sleep_period var word

clear
output heating_sensor_power
output motor_1
output motor_2
input heating_sensor
read 9, sleep_period
sleep_period = sleep_period * 10
read 6, device_id
'here the reset should be triggered
if 1 == 0 then
    write 0, 40
    write 1, "R"
    write 2, "O"
    write 3, "B"
    write 4, "I"
    write 5, "K"
    write 6, 0
    write 7, 0
    write 8, 0
    END
endif
low HEATING_SENSOR_power
GOSUB MotorStop
normalMode = 0
READ 7, motorFullRangeTicks.HighByte
READ 8, motorFullRangeTicks.LOWBYTE
gosub initModule
'--------------Common RX-TX settings--------------------------------------------
commonSettings:
gosub commonRXTX
'============Main Rx============================================================
READ 6, temp_byte
if (temp_byte != 0) then
    normalMode = 1
endif
Main_rx:
gosub setup_rx 'setup Rx
pause 2 'delay for Rx starting
Ce=1 'set nRF24L01 in Rx mode
irqLoop:
if (sendCurrPosFlag == 1) then
   sendCurrPosFlag = 0
   gosub sendCurrentPosition
endif
if (normalMode == 1) then
      normalMode = 2
       seconds = 0
      'ok send temperature wait for the response 4 seconds and sleep 10 minutes
      gosub sendTemperature
endif
'Check for data to send
if (temp_data[0] != 0) then
    if (configure == 1) then
        gosub commonRXTX
        configure = 2
    endif
    gosub sendData
    TEMP_data[0] = 0
    if (sendCurrPosFlag2 == 1) then
        sendCurrPosFlag2 = 0
        sendCurrPosFlag = 1
    endif
    GOTO main_rx
endif
if (normalMode == 3) then
      disable
      INTCON = 0
      PIE1 = 0
      gosub setup_sleep
      pause 10
      sleep sleep_period
      pause 10
      seconds = 0
      ticks = 0
      INTCON = %11100000
      PIE1 = %00100000
      OPTION_REG = %00000111
      enable
      normalMode = 1
      goto commonSettings
endif
if (configure == 2) then
    read 6, device_id
    TEMP_data[0] = "A"
    TEMP_data[1] = "s"
    TEMP_data[2] = 13
    TEMP_data[3] = 10
    gosub sendData
    gosub adaptHead
    TEMP_data[1] = "e"
    gosub sendData
    configure = 0
    GOTO main_rx
endif
if (normalMode == 2) then
    if (seconds > 2) then
        if (motorRunning == 0) then
            'OK, go to sleep
            normalMode = 3
        endif      
    endif
endif
If Irq !=0 then irqLoop 'wait until IRQ, active low
Ce=0
lop:
data_out[0]=rd_rx_pload 'Read 5 bytes Rx pload
num_byte=payloadLength
gosub spi_read
temp_data[0] = 0
if (data_in[1] == device_id) then
    if (data_in[2] == "c") then    
        if (data_in[3] == "=") then
            'OK it is configure
            write 0, data_in[9]
            write 1, data_in[4]            
            write 2, data_in[5]            
            write 3, data_in[6]            
            write 4, data_in[7]            
            write 5, data_in[8]            
            write 6, data_in[10]            
            pause 10
            configure = 1
            device_id = data_in[10]
            gosub sendDataOK
        endif    
    elseif (data_in[2] == "l") then
        if (data_in[3] == "=") then
            read 6, temp_byte
            if (temp_byte != 0) then
                i = 4
                gosub convertInputData
                if (confSuccess == 1) then                
                    if (temp_byte < 101) then 
                        motorFullRangeExpectedTicks = (motorFullRangeTicks / 100) * temp_byte
                        if (temp_byte == 100) then motorFullRangeExpectedTicks = motorFullRangeTicks 
                        if (motorFullRangeExpectedTicks != motorFullRangeCurrentTicks) THEN
                            if (motorFullRangeExpectedTicks > motorFullRangeCurrentTicks) then
                                GOSUB MotorCloseHead            
                            else
                                GOSUB MotorOpenHead            
                            endif
                        else
                            sendCurrPosFlag2 = 1
                        endif
                        gosub sendDataOK
                    endif
                endif
            endif
        endif
    elseif (data_in[2] == "a") then
            if (data_in[3] == "d") then
                configure = 2
                gosub sendDataOK
            endif
    ELSEif (data_in[2] == "m") then    
        if (data_in[3] == "=") then
            I=4
            GOSUB convertInputData
            if (confSuccess = 1) then
                write 9, temp_byte
                sleep_period = temp_byte * 10
                if (sleep_period == 0) then 
                    normalMode = 0                
                else
                    normalMode = 1
                endif
                gosub sendDataOK
            endif
        ENDIF
    ELSEif (data_in[2] == "s") then    
            gosub sendTemperature
    elseif (data_in[2] == "p") then
            if (data_in[3] == "n") then
                gosub sendDataOK
            endif
    endif
    if (temp_data[0] == 0) then
        gosub sendError
    endif
endif
data_out[0]=Fifo_status 'Read FIFO status
num_byte=1
gosub spi_read
val= data_in[1] 'FIFO status register
if val.0=0 then lop 'test RX_EMPTY=1, RX_FIFO empty
data_out[0]=Write_reg+Stat_us 'reset RX_DR status bit
data_out[1]=%01000000 'write 1 tp RX_DR to reset IRQ
num_byte=1
gosub spi_write
pause 2 'wait 2ms Rx<->Tx
GOTO Main_rx
end

disable
intManagement:
        if (INTCON.2 == 1) then
           ticks = ticks + 1      ' Count pieces of seconds
           'keep position of valve           
           if (normalmode < 4) then
               if (motorRunning == 1) then
                    if (motorFullRangeCurrentTicks == 65535) then motorFullRangeCurrentTicks = 65534
                    motorFullRangeCurrentTicks = motorFullRangeCurrentTicks + 1
                    gosub manageMotorStopInt
               endif
               if (motorRunning == 2) then
                    if (motorFullRangeCurrentTicks == 0) then motorFullRangeCurrentTicks = 1                    
                    motorFullRangeCurrentTicks = motorFullRangeCurrentTicks - 1
                    gosub manageMotorStopInt
               endif           
           endif
           if (normalmode == 4) then
                motorFullRangeTicks = motorFullRangeTicks + 1
           endif
           if ((ticks // 5) = 0) then
                'read adc if motor is running and stop if it's blocked
                if (motorRunning > 0) then
                    adcin 7, testAnInterrupt
                    if (testAnInterrupt < ((motorValNoPower / 100)*95)) then
                        if (motorAnVal > (testAnInterrupt + 500*motorStrengthConstant)) then
                            motorAnDownCount = motorAnDownCount + 1
                            if (motorAnDownCount > 1) then
                                if (motorRunning == 1) then motorFullRangeCurrentTicks = motorFullRangeTicks
                                if (motorRunning == 2) then motorFullRangeCurrentTicks = 0
                                gosub motorstopInt
                            endif
                        else
                            motorAnVal = testAnInterrupt
                            motorAnDownCount = 0
                        endif
                    endif
                endif
           endif
           If ticks < 31 Then tiexit
           ticks = 0
           seconds = seconds + 1
           if seconds <= 58 then tiexit
           seconds = 0
           tiexit: 
           INTCON.2 = 0
        endif
        INTCON.7 = 1
resume

manageMotorStopInt:
   if (motorFullRangeCurrentTicks == motorFullRangeExpectedTicks) then 
        gosub motorStopInt
   endif
return

motorStopInt:
    low MOTOR_1
    low MOTOR_2
    motorRunning = 0
    sendCurrPosFlag = 1
return

enable

sendCurrentPosition:
    if (configure != 2) then
      temp_data[0] = "l"
      temp_data[1] = "|"
      temp_byte = (motorFullRangeCurrentTicks * 10) / (motorFullRangeTicks / 10)
      temp_data[2] = (temp_byte DIG 2) + $30
      temp_data[3] = (temp_byte DIG 1) + $30
      temp_data[4] = (temp_byte DIG 0) + $30
      temp_data[5] = 13
      temp_data[6] = 10
    endif
return

sendError:
        temp_data[0] = "E"
        temp_data[1] = "R"
        temp_data[2] = "R"
        temp_data[3] = "O"
        temp_data[4] = "R"
        temp_data[5] = 13
        temp_data[6] = 10
return

sendDataOK:
    temp_data[0] = "O"
    temp_data[1] = "K"
    temp_data[2] = 13
    temp_data[3] = 10
return

convertInputData:
    TEMP_BYTE=0
    confSuccess = 0
    for ic=0 to 2    
        TEMP1_BYTE = "a"
        TEMP2_BYTE = data_in[i]
        if (TEMP2_BYTE == "|") then return
        GOSUB lookupChar
        if (TEMP1_BYTE == "a") then return 
        if (ic==0) then 
            TEMP_BYTE = TEMP1_BYTE
            confSuccess = 1 
        else 
            TEMP_BYTE = TEMP_BYTE*10 + TEMP1_BYTE 
            confSuccess = 1
        endif
        i = i + 1
    next ic
return

lookupChar:
    LOOKDOWN temp2_byte,["0123456789"], temp1_byte
RETURN

sendTemperature:
    high HEATING_SENSOR_power
    pause 50
   'read current temperature    
   OWOUT HEATING_SENSOR, 1, [$CC, $44] 'Skip ROM search & do temp conversion
Wait_Up:
   OWIN HEATING_SENSOR, 4, [Busy]      'Read busy-bit
   IF Busy = 0 THEN goto Wait_Up            'Still busy..?, Wait_Up..!
   OWOUT HEATING_SENSOR, 1, [$CC, $BE] 'Skip ROM search & read scratchpad memory
   OWIN HEATING_SENSOR, 2, [temperature.Lowbyte, temperature.Highbyte] 'Read two bytes / end comms
   low HEATING_SENSOR_power
   temp_data[0] = "t"
   temp_data[1] = "|"
   if (temperature.11 = 1) then
        temp_data[2] = "-"
        Dummy = 625 * (~temperature+1)
        TempC = DIV32 10
        temp_data[3] = (TempC DIG 4) + $30
        temp_data[4] = (TempC DIG 3) + $30
        temp_data[5] = "."
        temp_data[6] = (TempC DIG 2) + $30
        temp_data[7] = (TempC DIG 1) + $30
   else
        temp_data[2] = "+"
        Dummy = 625 * temperature
        TempC = DIV32 10
        TempC  = (temperature & $0FF0) >> 4 ' Mask middle 8-bits, shift into lower byte
        Float = ((temperature.Lowbyte & $0F) * 625) ' Lower 4-bits of result * 625
        temp_data[3] = (TempC DIG 1) + $30
        temp_data[4] = (TempC DIG 0) + $30
        temp_data[5] = "."
        temp_data[6] = (Float DIG 3) + $30
        temp_data[7] = (Float DIG 2) + $30
   endif
        'read baterry        
        VRCON.4 = 1 ; Turn 0.6V reference ON
        PAUSEUS 200 ; Allow VP6 to settle
        ADCIN 13, temp_word ; get VP6 analog reading (10-bit)
        VRCON.4 = 0 ; Turn 0.6V reference OFF
        VDD = 6138 / temp_word ; convert to voltage ve vdd je 25 = 2,5 V        
        temp_data[8] = "|"
        temp_data[9] = (VDD DIG 1) + $30
        temp_data[10] = "."
        temp_data[11] = (VDD DIG 0) + $30
        temp_data[12] = 13
        temp_data[13] = 10
return

MotorOpenHead:
    ADCIN 7, motorValNoPower
    LOW MOTOR_1
    HIGH MOTOR_2
    motorRunning = 2
    motorAnVal = 0
    motorAnDownCount = 0
return

motorCloseHead:
    ADCIN 7, motorValNoPower
    LOW MOTOR_2
    HIGH MOTOR_1
    motorRunning = 1
    motorAnVal = 0
    motorAnDownCount = 0
return

motorStop:
    low MOTOR_1
    low MOTOR_2
    motorRunning = 0
return

adaptHead:
    normalmode = 5
    gosub motorOpenHead
  closingAdapt:
    if (motorRunning != 0) then goto closingAdapt
    normalmode = 4
    motorFullRangeTicks = 0
    gosub motorCloseHead
  openingAdapt:
    if (motorRunning != 0) then goto openingAdapt
    seconds = 0
    write 7, motorFullRangeTicks.highbyte
    write 8, motorFullRangeTicks.LOWbyte
    read 9, temp_byte
    if (temp_byte == 0) then 
        normalMode = 0
    else     
        normalmode = 1
    endif
return
