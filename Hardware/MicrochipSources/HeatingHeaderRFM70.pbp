'@  __config _INTRC_OSC_NOCLKOUT & _WDT_ON & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _FCMEN_OFF & _IESO_OFF & _BOR_ON & _PWRTE_ON
                 
@ DEVICE PIC16F690,INTRC_OSC_NOCLKOUT
@ DEVICE PIC16F690,WDT_ON
@ DEVICE PIC16F690,MCLR_OFF
@ DEVICE PIC16F690,CPD_OFF
@ DEVICE PIC16F690,BOD_ON
@ DEVICE PIC16F690,PWRT_ON

'EEPROM_MAP
'0 - channel number
'1,2,3,4,5 bank name
'6 device id
'7 full range highByte
'8 full range lowbyte
'9 interval
'10 temperature - it is temperature / 2

INCLUDE "RFM70.pbp"

EEPROM  0, [40,"R","O","B","I","K",0,0,0,0,0,0,0,0,0,0]

 DEFINE OSC 8
 DEFINE ADC_BITS 10 ' ADCIN resolution (Bits)
 DEFINE ADC_CLOCK 3 ' ADC clock source (Fosc/32)
 DEFINE ADC_SAMPLEUS 50 ' ADC sampling time (uSec)
 ADCON0.7 = 1
 
 OSCCON = %01110000 ' Internal 8MHz osc
 ANSEL = %10000000
 ANSELH = 0
 CM1CON0 = 0
 CM2CON0 = 0
 
 'interrupt for timer
 INTCON = %10100000
 PIE1 = %00000000
 OPTION_REG = %00000111

on interrupt goto intManagement
ENABLE
'-----------init----------------------------------------------------------------
TRISA = %00100000 'Set PORTA to all output
TRISB = %00010000 'Set , SDI input
TRISC = %00001100 'Set IRQ input, 

HEATING_SENSOR var PORTA.5
HEATING_SENSOR_power var PORTA.4
MOTOR_1 var PORTC.4
MOTOR_2 var PORTC.5
MOTOR_ANALOG VAR PORTC.3
motorRunning VAR byte
motorAnVal var word
motorValNoPower var word
motorAnDownCount VAR byte
motorStrengthConstant var byte
motorStrengthConstant = 1    'this should be configurable
motorFullRangeTicks var word
motorFullRangeCurrentTicks var word
motorFullRangeExpectedTicks var word
testAnInterrupt var word
i VAR BYTE 'loop counter
j var byte
ic var byte
VDD VAR WORD
confSuccess var byte
configure var byte
manageSerial var byte
temp_byte_int var byte
temp_byte var byte
temp1_byte var byte
temp2_byte var byte
temp3_byte var byte
temp_word var word
temperature var word
seconds  var    byte    ' Define second variable
secondsMotorRunningProtection var byte
ticks   var     byte    ' Define pieces of seconds variable
dat var word 'unscaled ADC data
normalMode VAR byte
sendCurrPosFlag VAR byte
sendCurrPosFlag2 var byte
Dummy       VAR BYTE
TempC       VAR WORD
Float       VAR WORD        
busy        var BIT
sleep_period var word
errorFlag var byte
temperatureExp var byte

clear
output heating_sensor_power
output motor_1
output motor_2
input heating_sensor
read 9, sleep_period
read 6, device_id
read 10, temperatureExp

'here the reset should be triggered
if 1 == 0 then
    write 0, 40
    write 1, "R"
    write 2, "O"
    write 3, "B"
    write 4, "I"
    write 5, "K"
    write 6, 0
    write 7, 0
    write 8, 0
    write 9, 0
    write 10, 0
    END
endif
low HEATING_SENSOR_power
GOSUB MotorStop
normalMode = 0
READ 7, motorFullRangeTicks.HighByte
READ 8, motorFullRangeTicks.LOWBYTE
gosub initModule
'--------------Common RX-TX settings--------------------------------------------
commonSettings:
gosub commonRXTX
'============Main Rx============================================================
if (device_id != 0) then
    gosub setModeBasedOnSleepPeriod 
endif
Main_rx:
gosub setup_rx 'setup Rx
pause 2 'delay for Rx starting
Ce=1 'set nRF24L01 in Rx mode
irqLoop:
if (sendCurrPosFlag == 1) then
   sendCurrPosFlag = 0
   gosub sendCurrentPosition
endif
if (normalMode == 1) then
    if (sleep_period != 0) then
      normalMode = 2
       seconds = 0
       ticks = 0
      'ok send status wait for the response 2 seconds and sleep sleep_time seconds
      gosub sendTemperature
    endif
endif
'Check for data to send
if (temp_data[0] != 0) then
    if (configure == 1) then
        gosub commonRXTX
        configure = 2
    endif
    gosub sendData
    TEMP_data[0] = 0
    if (sendCurrPosFlag2 == 1) then
        sendCurrPosFlag2 = 0
        sendCurrPosFlag = 1
    endif
    GOTO main_rx
endif
if (normalMode == 3) then
        'OK, if the expected temperature is set set the head
      if (temperatureExp != 0) then
         if (temperature.11 != 1) then                          
             if (temperatureExp > temp3_byte) then
                temp2_byte = temperatureExp - temp3_byte
                if (temp3_byte < 7) then
                    temp_byte = 0
                elseif (temp2_byte == 3) then
                    temp_byte = 50
                elseif (temp2_byte == 2) then
                    temp_byte = 70
                elseif (temp2_byte == 1) then
                    temp_byte = 90
                else
                    temp_byte = 0
                endif
             else
                temp_byte = 100
             endif
         else
            'temperature is minus open the valve
            temp_byte = 0          
         endif
        gosub setValveBeforeSleep
      endif      
      disable
      INTCON = 0
      gosub setup_sleep
      pause 10
      sleep sleep_period * 10
      pause 10
      seconds = 0
      ticks = 0
      INTCON = %10100000
      OPTION_REG = %00000111
      enable
      normalMode = 1
      goto commonSettings
endif
if (configure == 2) then
    read 6, device_id
    TEMP_data[0] = "A"
    TEMP_data[1] = "s"
    TEMP_data[2] = 13
    TEMP_data[3] = 10
    gosub sendData
    gosub adaptHead
    if (errorFlag == 1) then
        errorFlag = 0
        gosub motorStop
        gosub sendError
    else 
        TEMP_data[1] = "e"
    endif
    gosub sendData
    configure = 0
    GOTO main_rx
endif
if (normalMode == 2) then
    if (seconds > 1) then
        if (motorRunning == 0) then
            'go to sleep
            normalMode = 3
        endif      
    endif
endif
If Irq !=0 then irqLoop 'wait until IRQ, active low
Ce=0
lop:
data_out[0]=rd_rx_pload 'Read 5 bytes Rx pload
num_byte=payloadLength
gosub spi_read
temp_data[0] = 0
if (data_in[1] == device_id) then
    if (data_in[3] == "=") then
        i = 4
        gosub convertInputData
        if (data_in[2] == "c") then    
            'OK it is configure
            write 0, data_in[9]
            write 1, data_in[4]            
            write 2, data_in[5]            
            write 3, data_in[6]            
            write 4, data_in[7]            
            write 5, data_in[8]            
            write 6, data_in[10]            
            pause 10
            configure = 1
            device_id = data_in[10]
            gosub sendDataOK
        elseif (confSuccess == 1) then                
            if (data_in[2] == "l") then   
                if (device_id != 0) then
                    if (temp_byte < 101) then 
                        gosub setValveToPosition
                        gosub sendDataOK
                    endif
                endif
            elseif (data_in[2] == "m") then   
                write 9, temp_byte
                sleep_period = temp_byte
                gosub setModeBasedOnSleepPeriod
                gosub sendDataOK
            elseif (data_in[2] == "t") then 
                write 10, temp_byte
                temperatureExp = temp_byte
                gosub sendDataOK
            endif
        endif
    elseif (data_in[2] == "a") then
            if (data_in[3] == "d") then
                configure = 2
                gosub sendDataOK
            endif
    ELSEif (data_in[2] == "s") then    
            gosub sendTemperature
    elseif (data_in[2] == "p") then
            if (data_in[3] == "n") then
                gosub sendDataOK
            endif
    endif
    if (temp_data[0] == 0) then
        gosub sendError
    endif
endif
data_out[0]=Fifo_status 'Read FIFO status
num_byte=1
gosub spi_read
val= data_in[1] 'FIFO status register
if val.0=0 then lop 'test RX_EMPTY=1, RX_FIFO empty
data_out[0]=Write_reg+Stat_us 'reset RX_DR status bit
data_out[1]=%01000000 'write 1 tp RX_DR to reset IRQ
num_byte=1
gosub spi_write
pause 2 'wait 2ms Rx<->Tx
GOTO Main_rx
end

disable
intManagement:
        if (INTCON.2 == 1) then
           ticks = ticks + 1      ' Count pieces of seconds
           'keep position of valve           
           if (normalmode < 4) then
               if (motorRunning == 1) then
                    if (motorFullRangeCurrentTicks != 65535) then motorFullRangeCurrentTicks = motorFullRangeCurrentTicks + 1
                    gosub manageMotorStopInt
               endif
               if (motorRunning == 2) then
                    if (motorFullRangeCurrentTicks != 0) then motorFullRangeCurrentTicks = motorFullRangeCurrentTicks - 1
                    gosub manageMotorStopInt
               endif           
           endif
           if (normalmode == 4) then
                motorFullRangeTicks = motorFullRangeTicks + 1
           endif
           if ((ticks // 5) = 0) then
                'read adc if motor is running and stop if it's blocked
                if (motorRunning > 0) then
                    input MOTOR_ANALOG
                    adcin 7, testAnInterrupt
                    output MOTOR_ANALOG
                    if (testAnInterrupt < ((motorValNoPower / 100)*97)) then
                        if (motorAnVal > (testAnInterrupt + 300*motorStrengthConstant)) then
                            motorAnDownCount = motorAnDownCount + 1
                            if (motorAnDownCount > 1) then
                                if (motorRunning == 1) then motorFullRangeCurrentTicks = motorFullRangeTicks
                                if (motorRunning == 2) then motorFullRangeCurrentTicks = 0
                                gosub motorstopInt
                            endif
                        else
                            motorAnVal = testAnInterrupt
                            motorAnDownCount = 0
                        endif
                    endif
                endif
           endif
           If ticks < 31 Then tiexit
           ticks = 0
           seconds = seconds + 1
           secondsMotorRunningProtection = secondsMotorRunningProtection + 1
           if seconds <= 58 then tiexit
           seconds = 0
           tiexit: 
           INTCON.2 = 0
        endif
        INTCON.7 = 1
resume

manageMotorStopInt:
   if (motorFullRangeCurrentTicks == motorFullRangeExpectedTicks) then 
        gosub motorStopInt
   endif
return

motorStopInt:
    low MOTOR_1
    low MOTOR_2
    motorRunning = 0
    sendCurrPosFlag = 1
return

enable

setValveToPosition:
      motorFullRangeExpectedTicks = (motorFullRangeTicks / 100) * temp_byte
      if (temp_byte == 100) then motorFullRangeExpectedTicks = motorFullRangeTicks 
      if (motorFullRangeExpectedTicks != motorFullRangeCurrentTicks) THEN
          if (motorFullRangeExpectedTicks > motorFullRangeCurrentTicks) then
              GOSUB MotorCloseHead            
          else
              GOSUB MotorOpenHead            
          endif
      else
          sendCurrPosFlag2 = 1
      endif
return

setValveBeforeSleep:
             gosub setValveToPosition
             if (motorRunning == 0) then
                  sendCurrPosFlag2 = 0
                  return
             else
                 backRun:
                 if (motorRunning > 0) then backRun
                 gosub sendCurrentPosition
                 gosub sendData
                 sendCurrPosFlag = 0
             endif
return

sendCurrentPosition:
    if (configure != 2) then
      temp_data[0] = "l"
      i=1
      gosub printFullRangeTicks
    endif
return

sendError:
        temp_data[0] = "E"
        temp_data[1] = "R"
        temp_data[2] = "R"
        temp_data[3] = "O"
        temp_data[4] = "R"
        temp_data[5] = 13
        temp_data[6] = 10
return

sendDataOK:
    temp_data[0] = "O"
    temp_data[1] = "K"
    temp_data[2] = 13
    temp_data[3] = 10
return

convertInputData:
    TEMP_BYTE=0
    confSuccess = 0
    for ic=0 to 2    
        TEMP1_BYTE = "a"
        TEMP2_BYTE = data_in[i]
        if (TEMP2_BYTE == "|") then return
        GOSUB lookupChar
        if (TEMP1_BYTE == "a") then return 
        if (ic==0) then 
            TEMP_BYTE = TEMP1_BYTE
            confSuccess = 1 
        else 
            TEMP_BYTE = TEMP_BYTE*10 + TEMP1_BYTE 
            confSuccess = 1
        endif
        i = i + 1
    next ic
return

lookupChar:
    LOOKDOWN temp2_byte,["0123456789"], temp1_byte
RETURN

sendTemperature:
    high HEATING_SENSOR_power
    pause 50
   'read current temperature    
   OWOUT HEATING_SENSOR, 1, [$CC, $44] 'Skip ROM search & do temp conversion
Wait_Up:
   OWIN HEATING_SENSOR, 4, [Busy]      'Read busy-bit
   IF Busy = 0 THEN goto Wait_Up            'Still busy..?, Wait_Up..!
   OWOUT HEATING_SENSOR, 1, [$CC, $BE] 'Skip ROM search & read scratchpad memory
   OWIN HEATING_SENSOR, 2, [temperature.Lowbyte, temperature.Highbyte] 'Read two bytes / end comms
   low HEATING_SENSOR_power
   temp_data[0] = "4"
   temp_data[1] = "|"
   if (temperature.11 == 1) then
        temp_data[2] = "-"
        disable
        Dummy = 625 * (~temperature+1)
        TempC = DIV32 10
        enable
        temp_data[3] = (TempC DIG 4) + $30
        temp_data[4] = (TempC DIG 3) + $30
   else
        disable
        Dummy = 625 * temperature
        TempC = DIV32 10
        enable
        TempC  = (temperature & $0FF0) >> 4 ' Mask middle 8-bits, shift into lower byte
        Float = ((temperature.Lowbyte & $0F) * 625) ' Lower 4-bits of result * 625
        temp_data[2] = (TempC DIG 1) + $30
        temp_data[3] = (TempC DIG 0) + $30
        temp_data[4] = (Float DIG 3) + $30
        temp3_byte = TempC.lowbyte * 2
        if ((temp_data[4] - $30) > 4) then temp3_byte = temp3_byte + 1
   endif
        'read baterry        
        VRCON.4 = 1 ; Turn 0.6V reference ON
        PAUSEUS 200 ; Allow VP6 to settle
        ADCIN 13, temp_word ; get VP6 analog reading (10-bit)
        VRCON.4 = 0 ; Turn 0.6V reference OFF
        VDD = 6138 / temp_word ; convert to voltage ve vdd je 25 = 2,5 V        
        temp_data[5] = "|"
        temp_data[6] = (VDD DIG 1) + $30
        temp_data[7] = (VDD DIG 0) + $30
        temp_data[8] = "|"
        temp_byte = sleep_period
        i=9
        gosub printByteToTempByte
        temp_data[12] = "|"
        i=12
        temp_byte = temperatureExp
        gosub print2LastBytesToTempByte
        i=15
        gosub printFullRangeTicks
return

printFullRangeTicks:
        temp_data[i] = "|"
        temp_byte = (motorFullRangeCurrentTicks * 10) / (motorFullRangeTicks / 10)
        i=i+1
        gosub printByteToTempByte
        temp_data[i+3] = 13
        temp_data[i+4] = 10
return

printByteToTempByte:        
        temp_data[i] = (temp_byte DIG 2) + $30
print2LastBytesToTempByte:
        temp_data[i+1] = (temp_byte DIG 1) + $30
        temp_data[i+2] = (temp_byte DIG 0) + $30
return

MotorOpenHead:
    ADCIN 7, motorValNoPower
    LOW MOTOR_1
    HIGH MOTOR_2
    motorRunning = 2
    motorAnVal = 0
    motorAnDownCount = 0
return

motorCloseHead:
    ADCIN 7, motorValNoPower
    LOW MOTOR_2
    HIGH MOTOR_1
    motorRunning = 1
    motorAnVal = 0
    motorAnDownCount = 0
return

motorStop:
    low MOTOR_1
    low MOTOR_2
    motorRunning = 0
return

adaptHead:
    errorFlag = 0
    normalmode = 5
    gosub motorOpenHead
    secondsMotorRunningProtection = 0
  closingAdapt:
    if (secondsMotorRunningProtection > 200) then
        errorFlag = 1
        RETURN
    endif
    if (motorRunning != 0) then goto closingAdapt
    normalmode = 4
    motorFullRangeTicks = 0
    gosub motorCloseHead
    secondsMotorRunningProtection = 0
  openingAdapt:
    if (secondsMotorRunningProtection > 200) then
        errorFlag = 1
        RETURN
    endif
    if (motorRunning != 0) then goto openingAdapt
    seconds = 0
    write 7, motorFullRangeTicks.highbyte
    write 8, motorFullRangeTicks.LOWbyte
    gosub setModeBasedOnSleepPeriod
return

setModeBasedOnSleepPeriod:
    if (sleep_period == 0) then 
        normalMode = 0
    else     
        normalmode = 1
    endif
return
