'@  __config _INTRC_OSC_NOCLKOUT & _WDT_ON & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _FCMEN_OFF & _IESO_OFF & _BOR_ON & _PWRTE_ON
                 
@ DEVICE PIC16F690,INTRC_OSC_NOCLKOUT
@ DEVICE PIC16F690,WDT_ON
@ DEVICE PIC16F690,MCLR_OFF
@ DEVICE PIC16F690,CPD_OFF
@ DEVICE PIC16F690,BOD_ON
@ DEVICE PIC16F690,PWRT_ON

'EEPROM_MAP
'0 - channel number
'1,2,3,4,5 bank name
'6 device id
'7 timeout value 1
'8 timeout value 2
'9 timeout value 3

EEPROM  0, [40,"R","O","B","I","K",0,1,1,1,0,0,0,0,0,0]

INCLUDE "RFM73.pbp"

 DEFINE OSC 8

 OSCCON = %01110000 ' Internal 8MHz osc
 ANSEL = 0
 ANSELH = 0
 CM1CON0 = 0
 CM2CON0 = 0
 
 'interrupt for timer
    INTCON = %10100000  'T01 enabled PEIE disabled.
    PIE1 = %00000000    'USART disabled
    OPTION_REG = %00000100

on interrupt goto intManagement
ENABLE
'-----------init----------------------------------------------------------------
TRISA = %00000000 'Set PORTA to all output
TRISB = %00110000 'Set , SDI input
TRISC = %00000100 'Set IRQ input, 

RELAY1_DOWN VAR PORTA.5
RELAY1_UP VAR PORTA.4
RELAY2_DOWN VAR PORTC.4
RELAY2_UP VAR PORTC.3
RELAY3_DOWN VAR PORTC.6
RELAY3_UP VAR PORTC.5
RES var PORTB.5

i VAR BYTE 'loop counter
iint var byte
icurrpos var byte
icurrposArr var byte
relaysGroup var byte
j var byte
ci var byte
configure var byte
temp_byte_int var byte
temp_byte var byte
temp1_byte var byte
temp2_byte var byte
temp3_byte var byte
temp4_byte var byte
temp_word var word
temp2_word var word
temp3_word var word
EEPROMBYTE      VAR BYTE
EEPROMPOSITION  VAR BYTE
seconds  var     byte    ' Define second variable
ticks   var     byte    ' Define pieces of seconds variable
counter var word[3]
initialCounter var word[3]
initialPercent var byte[3]
conversionSuccess VAR BYTE
timeout_value var word[3]
currentCounter var byte[3]
currentDirection var byte[3]

clear
read 6, device_id
read 7, timeout_value[0]
timeout_value[0] = timeout_value[0] * 30
read 8, timeout_value[1]
timeout_value[1] = timeout_value[1] * 30
read 9, timeout_value[2]
timeout_value[2] = timeout_value[2] * 30

output RELAY1_DOWN
output RELAY1_UP
output RELAY2_DOWN
output RELAY2_UP
output RELAY3_DOWN
output RELAY3_UP
input res

gosub initModule

commonSettings:
gosub commonRXTX

'============Main Rx============================================================
Main_rx:
gosub setup_rx 'setup Rx
pause 2 'delay for Rx starting
Ce=1 'set nRF24L01 in Rx mode
irqLoop:
if RES == 0 then
    write 0, 40
    write 1, "R"
    write 2, "O"
    write 3, "B"
    write 4, "I"
    write 5, "K"
    write 6, 0
    write 7, 1
    write 8, 1
    write 9, 1
    pause 1000
endif
'Check for data to send
if (temp_data[0] != 0) then
    if (configure == 1) then
        gosub commonRXTX
        configure = 0
    endif
    gosub sendData
    temp_data[0] = 0
    GOTO main_rx
endif
If Irq !=0 then irqLoop 'wait until IRQ, active low
Ce=0
lop:
data_out[0]=rd_rx_pload 'Read 5 bytes Rx pload
num_byte=payloadLength
gosub spi_read
temp_data[0] = 0
if (data_in[1] == device_id) then
    if (data_in[2] == "c") then    
        if (data_in[3] == "=") then
            'OK it is configure
            write 0, data_in[9] 'channel
            write 1, data_in[4] 'password 0
            write 2, data_in[5] 'password 1
            write 3, data_in[6] 'password 2
            write 4, data_in[7] 'password 3
            write 5, data_in[8] 'password 4
            write 6, data_in[10]'device id
            device_id = data_in[10]
            pause 10
            configure = 1
            gosub sendDataOK
        endif
    elseif (data_in[2] == "b") then
        I = 3
        gosub convertInputData
        if (conversionSuccess == 1) then
            temp4_byte = temp_byte - 1 'this is relay number
            if (TEMP_BYTE > 0) then
                if (TEMP_BYTE < 4) then
                    if (data_in[4] == "t") then
                        if (data_in[5] == "=") then
                            i = 6
                            gosub convertInputData
                            if (conversionSuccess == 1) then
                                if (temp_byte != 0) then
                                     write (7+temp4_byte), temp_byte
                                     timeout_value[temp4_byte] = temp_byte * 30
                                     gosub sendDataOK
                                endif
                            endif                                   
                        endif
                    elseif (data_in[4] == "d") then
                        counter[temp4_byte] = timeout_value[temp4_byte]
                        initialcounter[temp4_byte] = counter[temp4_byte]
                        relaysGroup = temp4_byte
                        gosub blindsDown
                        initialPercent[temp4_byte] = currentCounter[temp4_byte]
                        currentCounter[temp4_byte] = 100
                        gosub sendDataOK
                    elseif (data_in[4] == "u") then
                        counter[temp4_byte] = timeout_value[temp4_byte]
                        initialCounter[temp4_byte] = counter[temp4_byte]
                        relaysGroup = temp4_byte
                        gosub blindsup
                        initialPercent[temp4_byte] = currentCounter[temp4_byte]            
                        currentCounter[temp4_byte] = 0
                        gosub sendDataOK
                    elseif (data_in[4] == "m") then
                        if (data_in[5] == "=") then
                            i = 6
                            gosub convertInputData
                            if (conversionSuccess == 1) then
                              if (temp_byte < 101) then
                                if (temp_byte == currentCounter[temp4_byte]) then
                                    gosub sendDataOK
                                    counter = 4
                                elseif (temp_byte > currentCounter[temp4_byte]) then
                                    temp2_byte = temp_byte - currentCounter[temp4_byte]
                                    initialPercent[temp4_byte] = currentCounter[temp4_byte]
                                    relaysGroup = temp4_byte
                                    gosub computeCounter
                                    initialCounter[temp4_byte] = counter[temp4_byte]
                                    gosub blindsDown
                                    currentCounter[temp4_byte] = temp_byte[temp4_byte]
                                    gosub sendDataOK
                                else
                                    temp2_byte = currentCounter[temp4_byte] - temp_byte
                                    initialPercent[temp4_byte] = currentCounter[temp4_byte]
                                    relaysGroup = temp4_byte
                                    gosub computeCounter
                                    initialCounter[temp4_byte] = counter[temp4_byte]
                                    gosub blindsUp
                                    currentCounter[temp4_byte] = temp_byte
                                    gosub sendDataOK
                                endif
                              endif  
                            endif                                                   
                        endif
                    elseif (data_in[4] == "s") then               
                        if (currentDirection[temp4_byte] != 0) then
                            temp_word = initialCounter[temp4_byte] - counter[temp4_byte]
                            disable
                            temp_word = temp_word * 100
                            temp2_word = DIV32 timeout_value[temp4_byte]
                            enable
                            if (currentDirection[temp4_byte] == 1) then
                                temp3_word = initialPercent[temp4_byte] + temp2_word
                                if (temp3_word > 100 ) then temp3_word = 100
                                currentCounter[temp4_byte] = temp3_word
                            elseif (currentDirection[temp4_byte] == 2) then
                                if (initialPercent[temp4_byte] > temp2_word) then
                                    currentCounter[temp4_byte] = initialPercent[temp4_byte] - temp2_word
                                else
                                    currentCounter[temp4_byte] = 0
                                endif
                            endif
                            gosub sendDataOK
                            counter[temp4_byte] = 4
                        else
                            gosub sendDataOK            
                            counter[temp4_byte] = 4
                        endif
                    endif
                endif
            endif
        endif
    elseif (data_in[2] == "s") then
        I = 3
        gosub convertInputData
        if (conversionSuccess == 1) then
            temp4_byte = temp_byte - 1 'this is relay number
            if (TEMP_BYTE > 0) then
                if (TEMP_BYTE < 4) then
                    temp_data[0] = "5"
                    temp_data[1] = "|"
                    if (temp4_byte == 0) then
                        temp_data[2] = RELAY1_DOWN + $30
                        temp_data[3] = "|"
                        temp_data[4] = RELAY1_UP + $30
                    elseif (temp4_byte == 1) then
                        temp_data[2] = RELAY2_DOWN + $30
                        temp_data[3] = "|"
                        temp_data[4] = RELAY2_UP + $30
                    elseif (temp4_byte == 2) then
                        temp_data[2] = RELAY3_DOWN + $30
                        temp_data[3] = "|"
                        temp_data[4] = RELAY3_UP + $30
                    endif
                    temp_data[5] = "|"            
                    temp_byte = timeout_value[temp4_byte] / 30
                    gosub convertNoToStr
                    temp_data[6] = temp3_byte
                    temp_data[7] = temp2_byte
                    temp_data[8] = temp1_byte
                    temp_data[9] = "|"            
                    temp_byte = currentCounter[temp4_byte]
                    gosub convertNoToStr
                    temp_data[10] = temp3_byte
                    temp_data[11] = temp2_byte
                    temp_data[12] = temp1_byte
                    temp_data[13] = 13    
                    temp_data[14] = 10
                endif
            endif
        endif
    elseif (data_in[2] == "p") then
            if (data_in[3] == "n") then
                gosub sendDataOK
            endif
    elseif (data_in[2] == "u") then
        I = 3
        gosub convertInputData
        if (conversionSuccess == 1) then
            if (temp_byte > 0) then
                if (temp_byte < 4) then
                    relaysGroup = temp_byte - 1
                    gosub blindsUp
                    gosub sendDataOK
                endif
            endif
        endif
    elseif (data_in[2] == "d") then
        I = 3
        gosub convertInputData
        if (conversionSuccess == 1) then
            if (temp_byte > 0) then
                if (temp_byte < 4) then
                    relaysGroup = temp_byte - 1
                    gosub blindsDown
                    gosub sendDataOK
                endif
            endif
        endif
    elseif (data_in[2] == "e") then
        I = 3
        gosub convertInputData
        if (conversionSuccess == 1) then
            if (temp_byte > 0) then
                if (temp_byte < 4) then
                    relaysGroup = temp_byte - 1
                    gosub stopBlindsSilent
                    gosub sendDataOK
                endif
            endif
        endif
    endif
    if (temp_data[0] == 0) then
        temp_data[0] = "E"
        temp_data[1] = "R"
        temp_data[2] = "R"
        temp_data[3] = "O"
        temp_data[4] = "R"
        temp_data[5] = 10
    endif
endif

data_out[0]=Fifo_status 'Read FIFO status
num_byte=1
gosub spi_read
val= data_in[1] 'FIFO status register
if val.0=0 then lop 'test RX_EMPTY=1, RX_FIFO empty
data_out[0]=Write_reg+Stat_us 'reset RX_DR status bit
data_out[1]=%01000000 'write 1 tp RX_DR to reset IRQ
num_byte=1
gosub spi_write
pause 2 'wait 2ms Rx<->Tx
GOTO Main_rx
end

disable
intManagement:
        if (INTCON.2 == 1) then
           ticks = ticks + 1      ' Count pieces of seconds
           for iint = 0 to 2
               if (counter[iint] > 0) then
                   counter[iint] = counter[iint] - 1
                   if (counter[iint] == 0) then
                        if (iint == 0) then
                            low RELAY1_DOWN
                            low RELAY1_UP
                            currentDirection[iint] = 0
                            gosub sendCurrentPosition
                        elseif (iint == 1) then
                            low RELAY2_DOWN
                            low RELAY2_UP                            
                            currentDirection[iint] = 0                            
                            gosub sendCurrentPosition
                        elseif (iint == 2) then
                            low RELAY3_DOWN
                            low RELAY3_UP                            
                            currentDirection[iint] = 0                            
                            gosub sendCurrentPosition
                        endif                        
                   endif
               endif
           next iint
           If ticks < 241 Then tiexit
           ticks = 0
           seconds = seconds + 1
           if seconds <= 59 then tiexit
           seconds = 0
           tiexit: 
           INTCON.2 = 0
        endif
        INTCON.7 = 1
resume
enable

stopBlinds:
    gosub stopBlindsSilent
    gosub sendCurrentPosition
return

stopBlindsSilent:
    if (relaysGroup == 0) then
        LOW RELAY1_DOWN
        low RELAY1_UP
    elseif (relaysGroup == 1) then
        LOW RELAY2_DOWN
        low RELAY2_UP
    elseif (relaysGroup == 2) then
        LOW RELAY3_DOWN
        low RELAY3_UP
    endif
    currentDirection[relaysGroup] = 0
return

blindsUp:
    gosub stopBlindsSilent
    pause 100
    if (relaysGroup == 0) then
        high RELAY1_DOWN
        low RELAY1_UP
    elseif (relaysGroup == 1) then
        high RELAY2_DOWN
        low RELAY2_UP
    elseif (relaysGroup == 2) then
        high RELAY3_DOWN
        low RELAY3_UP
    endif
    currentDirection[relaysGroup] = 2
return

blindsDown:
    gosub stopBlindsSilent
    pause 100
    if (relaysGroup == 0) then
        LOW RELAY1_DOWN
        HIGH RELAY1_UP
    elseif (relaysGroup == 1) then
        LOW RELAY2_DOWN
        HIGH RELAY2_UP
    elseif (relaysGroup == 2) then
        LOW RELAY3_DOWN
        HIGH RELAY3_UP
    endif
    currentDirection[relaysGroup] = 1
return

sendCurrentPosition:
    temp_data[0] = "l"
    for icurrpos = 0 to 2
        icurrposArr = (icurrpos*4) + 1
        temp_data[icurrposArr] = "|"
        temp_byte = currentCounter[icurrpos]
        gosub convertNoToStr
        temp_data[icurrposArr+1] = temp3_byte
        temp_data[icurrposArr+2] = temp2_byte
        temp_data[icurrposArr+3] = temp1_byte
    next icurrpos
    temp_data[13] = 13
    temp_data[14] = 10
return

computeCounter:
    disable
    temp_word = timeout_value[relaysGroup] * temp2_byte
    counter[relaysGroup] = div32 100
    enable
return

sendDataOK:
    temp_data[0] = "O"
    temp_data[1] = "K"
    temp_data[2] = 10
return

convertInputData:
    conversionSuccess = 0
    TEMP_BYTE="a"
    for ci=0 to 2    
        TEMP1_BYTE = "a"
        TEMP2_BYTE = data_in[i]
        if (TEMP2_BYTE == "|") then return
        GOSUB lookupChar
        if (TEMP1_BYTE == "a") then return 
        if (ci==0) then 
            TEMP_BYTE = TEMP1_BYTE
            conversionSuccess = 1 
        else 
            TEMP_BYTE = TEMP_BYTE*10 + TEMP1_BYTE
            conversionSuccess = 1
        endif
        i = i + 1
    next ci
return

lookupChar:
    LOOKDOWN temp2_byte,["0123456789"], temp1_byte
RETURN

convertNoToStr:
        temp3_byte = (temp_byte DIG 2) + $30
        temp2_byte = (temp_byte DIG 1) + $30
        temp1_byte = (temp_byte DIG 0) + $30
return
